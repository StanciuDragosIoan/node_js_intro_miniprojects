<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      href="https://fonts.googleapis.com/css2?family=Domine:wght@400;700&family=Open+Sans:ital,wght@0,400;0,600;0,700;1,400;1,600;1,700&family=Roboto&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="./assets/css/main.css" type="text/css" />
    <title>NodeJS Introduction</title>
  </head>
  <body>
    <h1 class="header">NodeJS Introduction</h1>

    <p class="text">
      As the title suggests, this article is an introduction to the
      <span class="snippet">NodeJS</span> runtime. In it, we will look at some
      basic concepts regarding the runtime, such as:
      <span class="snippet">JavaScript callbacks</span>,
      <span class="snippet">asynchronous programming</span>,
      <span class="snippet">JavaScript Modules</span> and some others, and we
      will also build some mini projects, very primitive, but useful for our
      next projects.. These things should teach you how to do basic back-end
      stuff such as processing submit data from a form, writing to and reading
      from files, handling a basic node server, etc..
    </p>
    <p class="text">
      Before starting to look at the NodeJS runtime, we need to clarify two
      concepts first, namely <span class="snippet">callbacks</span> and
      <span class="snippet">asynchronous programming</span> using JavaScript.
    </p>
    <p class="text center bold">Callback functions</p>
    <p class="text">
      Callbacks or callback functions are as their name implies, functions that
      execute after some other code (they are 'called back'). To be more
      precise, a callback function is passed as an argument to another function
      which calls it at a given time. They are also called 'call after'
      functions (because they usually run after some other function executed and
      'calls them back').
    </p>
    <p class="text">Let's see a little example of a callback function:</p>
    <pre class="code">
      //define callback
      const callBack = () => {
        console.log("callback called...");
      };

      //define main function
      const const mainFunction = (callBack) => {
        console.log("main function called...");
        //calling callback
        callBack();
      }


  //call main function which in turn calls the callback
      mainFunction(callBack);
    </pre>
    <p class="text">
      This is basically how everything works, but it gets even better, some
      JavaScript methods even take callback functions as default parameters,
      such functions include higher order functions like
      <span class="snippet">map</span>, <span class="snippet">sort</span>,
      <span class="snippet">filter</span>. Paste the below in your browser
      console (open with f12 on chrome) and hit enter:
    </p>
    <pre class="code">
  const arr = [1,2,3];
  const doubles = arr.map( (item) => item += item);
  console.log(doubles); // [2, 4, 6];
    </pre>
    <p class="text center bold">Asynchronous programming</p>
    <p class="text">
      Before we talk about asynchronous programming, we should clarify what
      synchronous is. Synchronous blocks of code have to wait for eachother to
      finish before the next block of code can run. A very basic example of that
      is the following code:
    </p>
    <pre class="code">
      const job = "Awesome Programmer";
      prompt("are you a programmer? ");
      console.log(job);
    </pre>
    <p class="text">
      Note how the <span class="snippet">console.log()</span> call did not
      execute until you confirmed the prompt. The same happens if you use the
      <span class="snippet">alert() method</span> because the
      <span class="snippet">prompt()</span> method and the other two are
      synchronous operations (blocking code which 'blocks' the 'call-stack'
      that's the order in which functions are executed inside our script). So
      until we confirm the prompt, nothing happens.
    </p>
    <p class="text">
      Let's now see an example in which asynchronous code is executed and the
      call stack is not blocked in the mean-time. Paste the below code in your
      browser console and hit enter:
    </p>
    <pre class="code">
      console.log("first operation is done");

      setTimeout(() => 
        { console.log("async operation has finished") }
          , 1000);

      console.log("third operation is called"); 
      
    </pre>
    <p class="text">The output of that will be:</p>
    <pre class="code">
      first operation is done
      third operation is called
      undefined
      async operation has finished
    </pre>
    <p class="text">
      The reason for that is that, the
      <span class="snippet">call-stack</span> saw the first operation's log and
      printed it, then it saw the <span class="snippet">setTimeout()</span> call
      and it handled it to the browser API (there are more of these, they can do
      awesome things and you will learn how to use them in time) to be processed
      asynchronously in the background (this lasts 1 second). Next it saw the
      last log for the 'third operation' and it printed it. Next the new kid in
      town pops up (that's the JavaScript Engine's
      <span class="snippet">Event Loop</span> -for now just read about it if you
      are curious ) and checks if there's any work for it to do. Since there is
      nothing (because the 1 second needed for
      <span class="snippet">setTimeout()</span> is not over yet)
      <span class="snippet">setTimeout()</span>
      returns undefined. Finally the one second is over and the 'async operation
      has finished'. This is how asynchronous programming works. In a
      synchronous setup, the 'third operation' log would have had to wait for 1
      second before being executed.
    </p>
    <p class="text center bold">How are callbacks used in nodeJS</p>
    <p class="text">
      NodeJS uses callbacks heavily in order to allow us to execute operations
      asynchronously, without blocking the execution thread. Instead of doing
      something like:
    </p>
    <pre class="code">
      const processFileData = () => {
        let fileData = getFileData();
        return data;
      }

    </pre>
    <p class="text">In node we would have something like:</p>
    <pre class="code">
      function processFileData (nextFuncToCall) {
        fetchData(function (err, fileData) {
          if (err) {
            console.log("Error, something went booBoo X__x");
            return nextFuncToCall(err);
          }
          fileData += 5;
          return nextFuncToCall(fileData);
        });
      }
    </pre>
    <p class="text">
      In this way the code execution does not have to pause for certain
      operations that take longer, such as network requests or reading data from
      a file (especailly if the file is very big). The code keeps executing and
      once it's done with the longer operation it calls back a 'callback
      function' without interrupting the execution of our program.
    </p>
    <p class="text center bold">JavaScript modules</p>
    <p class="text">
      The last element we need to discuss before diving into actual
      <span class="snippet">nodeJS</span> code and building some mini-projects
      which will get you familiar with the runtime, are JavaScript modules.
    </p>
    <p class="text">
      If you come from a different language such as
      <span class="snippet">PHP</span> or <span class="snippet">Java</span>, you
      are familiar with scripts which are 'imported' inside our application
      through a syntax such as:
    </p>
    <pre class="code">
      require_once("my awesome module");//PHP import
      import java.util.ArrayList; //Java import
    </pre>
    <p class="text">
      This is very handy as we can have whole bunch of functionalities grouped
      under separate files (or modules), which we can use throughout our
      applications.
    </p>
    <p class="text">
      JavaScript provides this mechanism as well. It did not use to have it, but
      modules got introduced to the language starting 2009 with the emergence of
      runtime environments such as
      <span class="snippet">nodeJS</span>.
    </p>
    <p class="text">
      We will discuss ES Modules (Ecma Script Modules) and common nodeJS
      modules.
    </p>
    <p class="text center bold">ES Modules</p>
    <p class="text">
      If we want to re-use a certain bit of JS code in different places
      throughout our app, we would do something like this:
    </p>
    <pre class="code">
      const myAwesomeLogger = () => 
        { console.log("Logged something awesome
      here.."); }

      //we will import this in a different file
      export { myAwesomeLogger }
    </pre>
    <p class="text">
      Let's create a little project now and have fun with some
      <span class="snippet">JS</span> modules and some
      <span class="snippet">nodeJS</span> scripts.
    </p>
    <p class="text">
      Create a directory (I named mine 'mini-projects'),
      <span class="snippet">cd</span> into it and run the below command:
    </p>
    <pre class="code">
      npm init -y
    </pre>
    <p class="text">
      This script generates you a <span class="snippet">package.json</span> file
      and configures a basic node project. The
      <span class="snippet">-y</span> flag just puts default values for keys
      such as: name, version, etc... If you ommit it, it will ask you for the
      values and I did not want you to waste time with this now. In a future
      project we will configure an <span class="snippet">npm</span> project more
      in depth.
    </p>
    <p class="text">
      Let's add a "start" script in the
      <span class="snippet">package.json</span> file. You can replace the test
      script with it, inside the 'scripts' object. Now your
      <span class="snippet">package.json</span> file looks like this:
    </p>
    <pre class="code">
      {
        "name": "mini-projects",
        "version": "1.0.0",
        "description": "",
        "main": "server.js",
        "scripts": {
          "start": "node server"
        },
        "keywords": [],
        "author": "",
        "license": "ISC"
      }      
    </pre>
    <p class="text">
      Next create a <span class="snippet">server.js</span> file (note that it is
      the one file that you just told the
      <span class="snippet">npm</span> script to execute when you run
      <span class="snippet">npm start</span>. Test that the file is executed by
      pasting a
      <span class="snippet"
        >console.log("Welcome to my first node script ^___^");</span
      >
      in it and runnning:
    </p>
    <pre class="code">
      npm start
    </pre>
    <p class="text">
      Now that your server runs, let's play a bit with
      <span class="snippet">JavaScript</span> modules.
    </p>
    <p class="text">
      Create a <span class="snippet">sampleJsModule.js</span> file and paste the
      below code in it:
    </p>
    <pre class="code">
      const sampleJsModule = () => {
        console.log("Module 1 here..");
      };
      
      export { sampleJsModule };      
    </pre>
    <p class="text">
      Next in the <span class="snippet">server.js</span> import the sample
      module:
    </p>
    <pre class="code">
console.log("Welcome to my first node script ٩(^ᴗ^)۶ !");

import { sampleJsModule } from "./sampleJsModule.js";

sampleJsModule();

    </pre>
    <p class="text">
      Next run <span class="snippet">npm start</span> and you will get a long
      error and if you scroll atop of it you will see:
    </p>
    <div class="devPic">
      <img src="./img/modules_error.png" alt="" />
    </div>
    <p class="text">
      We need to set the <span class="snippet">type</span> module in the
      <span class="snippet">package.json</span> file. Add it just as per below:
    </p>
    <pre class="code">
      {
        "name": "mini-projects",
        "version": "1.0.0",
        "description": "",
        "main": "server.js",
        "type": "module",
        "scripts": {
          "start": "node server"
        },
        "keywords": [],
        "author": "",
        "license": "ISC"
      }
    </pre>
    <p class="text">
      Next run <span class="snippet">npm start</span> again and the module will
      work. Congratz! You have just created, imported and used your first
      <span class="snippet">EcmaScript Module</span> !
    </p>
    <p class="text center bold">Node modules</p>
    <p class="text">
      Let's create another module this time let's call it
      <span class="snippet">NodeJSModule.js</span> and add the below code to it:
    </p>
    <pre class="code">
const nodeModule = {
  callModule: () => {
    console.log("Module from node 'module' called =) !");
  },
};
      
      module.exports = nodeModule;
    </pre>
    <p class="text">
      Next import it in <span class="snippet">server.js</span>:
    </p>
    <pre class="code">
      console.log("Welcome to my first node script ٩(^ᴗ^)۶ !");

      import { sampleJsModule } from "./sampleJsModule.js";

      const nodeModule = require("./NodeJSModule");

      sampleJsModule();

      nodeModule.callModule();

    </pre>
    <p class="text">
      Next comment out the import for the sample module and the call to its
      method. Also remove the "module" type from package.json:
    </p>
    <pre class="code">
      {
        "name": "mini-projects",
        "version": "1.0.0",
        "description": "",
        "main": "server.js",
        "scripts": {
          "start": "node server"
        },
        "keywords": [],
        "author": "",
        "license": "ISC"
      }      
    </pre>
    <p class="text">
      Now run <span class="snippet">npm start</span> and your node module works
      by default (you did not have to specify the "module" type anymore).
    </p>
    <p class="text center bold">A NodeJS Server</p>
    <p class="text">
      Now that you know how asynchronous programming, callbacks and node modules
      work, you are ready to start creating server-side applications using the
      <span class="snippet">nodeJS</span> runtime environment.
    </p>
    <p class="text">
      Let's use the same <span class="snippet">mini-projects</span> directory
      and the same NPM script. We will create a server in
      <span class="snippet">nodeJS</span>. First, move the 2 modules in a
      <span class="snippet">custom_modules</span> directory and keep them for
      reference. Next we will create a server. Replace the contents in
      <span class="snippet">server.js</span> with the below:
    </p>
    <pre class="code">
//import http module for our server
const http = require("http");

//define port for our server to listen to
const PORT = process.env.port || 5000;

//define request listener
const requestListener = (req, res) => {
  //define url
  const url = req.url;

  switch (url) {
    case "/":
      //write client response
      res.write(`
    &lt;h1&gt;Welcome to our nodeJS Server&lt;/h1&gt; 
    `);
      //send client response
      res.end();
      break;
  }
}


//create server
const server = http.createServer(requestListener);

//log some output to see everything's ok
console.log(`Server is running on port: 
            ${PORT} so our API is alive =)
            `);

//start the server
server.listen(PORT);

    </pre>
    <p class="text">
      Run now <span class="snippet">npm start</span> and if you go to
      <span class="snippet">
        <a href="http://localhost:5000/" target="_blank"
          >http://localhost:5000/</a
        ></span
      >
      you can see that the server is running. Also if you check in the console
      in the terminal prompt you used to start the server, you will see the
      <span class="snippet">console.log</span> above. In a nutsheell the code
      above uses a core <span class="snippet">nodeJS module</span> (you know
      what these are by now) namely the <span class="snippet">http</span> module
      to create a server. The server is created using the
      <span class="snippet">createServer()</span> method from the
      <span class="snippet">http</span> module. The method takes in a
      <span class="snippet">requestListener</span> method which takes in as
      parameters the <span class="snippet">request</span> and the
      <span class="snippet">response</span> objects. These objects help us read
      the server request and configure the server response. This is how a server
      works at a very basic level, it receives requests, processes them and
      returns a response. For instance we are using the request object to read
      the <span class="snippet">url</span> to which the request is being made
      (so we can have different routes in our applications, so different urls
      which to do different things). Once the server is created we log some
      successful output in the console and start the server with the
      <span class="snippet">listen()</span> method which takes in a port. The
      port is defined as
      <span class="snippet">process.env.port || 5000</span> (note the or ||
      operator there) so that if we ever deploy our application to a real
      server, it can also use the default configuration of that server, and if
      there is no default configuration there, it will use the port 5000.
    </p>
    <p class="text">
      I defined the request listener as a separate function to introduce you to
      it but most often you will see it defined and passed to the
      <span class="snippet">createServer()</span> method as an anonymous arrow
      function like so:
    </p>
    <pre class="code">
//import http module for our server
const http = require("http");

//define port for our server to listen to
const PORT = process.env.port || 5000;

//create server
const server = http.createServer( (req, res) => {
  //define url
  const url = req.url;

  switch (url) {
    case "/":
      //write client response
      res.write(`
    &lt;h1&gt;Welcome to our nodeJS Server&lt;/h1&gt; 
    `);
      //send client response
      res.end();
      break;
  }
});

//log some output to see everything's ok
console.log(`Server is running on port: 
            ${PORT} so our API is alive =)
            `);

//start the server
server.listen(PORT);
    </pre>
    <p class="text">
      Replace the code in <span class="snippet">server.js</span> with the
      snippet above, press <span class="snippet">ctrl + c</span> in the command
      prompt to stop the server and restart it by running
      <span class="snippet">npm start</span> and you will see that the
      application works exactly the same. Let's also add a default case in our
      <span class="snippet">switch</span> so that, if the client (the browser
      request) hits a random endpoint except the ones we are going to specify,
      the app returns a 404 page. Replace the
      <span class="snippet">server.js</span> contents as per below:
    </p>
    <pre class="code">
//import http module for our server
const http = require("http");

//define port for our server to listen to
const PORT = process.env.port || 5000;

//create server
const server = http.createServer( (req, res) => {
  //define url
  const url = req.url;

  switch (url) {
    case "/":
      //write client response
      res.write(`
    &lt;h1&gt;Welcome to our nodeJS Server&lt;/h1&gt; 
    `);
      //send client response
      res.end();
      break;
    default:
      res.write(`
      &lt;h1&gt;404 page not found X_x&lt;/h1&gt;  
      `);
      res.end();
      break;  
  }
});

//log some output to see everything's ok
console.log(`Server is running on port: 
            ${PORT} so our API is alive =)
            `);

//start the server
server.listen(PORT);
    </pre>
    <p class="text">Now stop the server again and before restarting it run:</p>
    <pre class="code">
      npm i --save -D nodemon
    </pre>
    <p class="text">
      This command installs <span class="snippet">nodemon</span> a dependency
      that restarts your server upon any change, without you having to stop it
      and restart it manually anymore.
    </p>
    <p class="text">
      Next modify the <span class="snippet">start</span> script in the scripts
      object in <span class="snippet">package.json</span> as per below:
    </p>
    <pre class="code">
      {
        "name": "mini-projects",
        "version": "1.0.0",
        "description": "",
        "main": "server.js",
        "scripts": {
          "start": "nodemon server.js"
        },
        "keywords": [],
        "author": "",
        "license": "ISC",
        "devDependencies": {
          "nodemon": "^2.0.6"
        }
      }
    </pre>
    <p class="text">
      Now, if you hit the
      <span class="snippet"
        ><a href="http://localhost:5000" target="_blank"
          >http://localhost:5000</a
        ></span
      >
      endpoint you get the view we set initially. As for any other url, for now
      we will get the 404 page. Test that by trying to go to
      <span class="snippet"
        ><a href="http://localhost:5000/test" target="_blank"
          >http://localhost:5000/test</a
        ></span
      >
    </p>
    <p class="text center bold">Logger mini project</p>
    <p class="text">
      Let's start working on the logger project. This will be a little logger
      application that will grab some user input and log it to a file in a
      nicely structured way.
    </p>
    <p class="text">
      Start by adding the endpoint for it in a
      <span class="snippet">case</span> in our switch statement. Add one for the
      <span class="snippet">/logger endpoint:</span>
    </p>
    <pre class="code">
//import http module for our server
const http = require("http");

//define port for our server to listen to
const PORT = process.env.port || 5000;

//create server
const server = http.createServer( (req, res) => {
  //define url
  const url = req.url;

  switch (url) {
    case "/":
      //write client response
      res.write(`
    &lt;h1&gt;Welcome to our nodeJS Server&lt;/h1&gt; 
    `);
      //send client response
      res.end();
      break;
    case "/logger": 
    res.write(`
    &lt;h1&gt;Welcome to our Logger Application&lt;/h1&gt; 
    `); 
    res.end();
    break;
      break;
    default:
      res.write(`
      &lt;h1&gt;404 page not found X_x&lt;/h1&gt;  
      `);
      res.end();
      break;  
  }
});

//log some output to see everything's ok
console.log(`Server is running on port: 
            ${PORT} so our API is alive =)
            `);

//start the server
server.listen(PORT);
    </pre>
    <p class="text">
      For simplicity's sake we will put all of our logger inside a separate
      module. Create a <span class="snippet">logger.js</span> file inside the
      <span class="snippet">custom_modules</span> directory and add the below to
      it:
    </p>
    <pre class="code">
const logger = {
  renderLoggerForm: (res) => {
    res.write(`
            &lt;form
                style="${logger.formStyles}"
                action="/logger"
                method="POST"
            &gt;
                &lt;input 
                  name="logText"
                  style="${logger.formField}"
                  type="text"&gt;
                &lt;button 
                  style="${logger.formBtn}"
                  type="submit"&gt;
                  Log something
                &lt;/button&gt;
            &lt;/form&gt;
        `);
  },

  formStyles: `
        display:block; 
        margin:auto; 
        margin-top:1rem;
        padding:2rem; 
        font-size:1rem; 
        background: #ddd; 
        border: 2px solid #000; 
        border-radius:5px;
        max-width:600px;
    `,

  formBtn: `
    display:block;
    margin:auto;
    width:60%;
    padding:0.5rem;
    font-size:2rem;
    margin-top:3rem;
  `,

  formField: `
    display:block;
    margin:auto;
    margin-top:1rem;
    text-align:center;
    font-size:2rem;
  `,
};
      
      module.exports = logger;
      
    </pre>
    <p class="text">
      Next, import the module up top in the
      <span class="snippet">server.js</span>:
    </p>
    <pre class="code">
const logger = require("./custom_modules/logger");
    </pre>
    <p class="text">
      Also we can use the logger method now in
      <span class="snippet">server.js</span>. Just add the call to it in the
      <span class="snippet">/logger</span> case
    </p>
    <pre class="code">
      case "/logger":
      res.write(`
    &lth1&gt;
      Welcome to our Logger Application
    &lt;/h1&gt; 
    `);
      logger.renderLoggerForm(res);
      res.end();
      break;
    </pre>
    <p class="text">
      Now if you go to
      <span class="snippet"
        ><a href="http://localhost:5000/logger" target="_blank"
          >http://localhost:5000/logger</a
        ></span
      >
      you can see our logger's form. Let's next add the logic for processing the
      data. Note that the form has an
      <span class="snippet">action</span> attribute and a
      <span class="snippet">method</span> one. Also, the input field has a
      <span class="snippet">name</span> attribute. That's what we will use to
      process the data. First, the <span class="snippet">action</span> says
      "/logger" so that's the <span class="snippet">route</span> we will hit
      with our http request. We already have it set up in our
      <span class="snippet">server.js</span> but we are not checking the request
      type and no matter what for now we just display the logging form. We need
      to change that. Modify the <span class="snippet">server.js</span> as per
      below:
    </p>
    <pre class="code">
//import http module for our server
const http = require("http");
const logger = require("./custom_modules/logger");

//define port for our server to listen to
const PORT = process.env.port || 5000;

//create server
const server = http.createServer((req, res) => {
  //define url
  const url = req.url;
  //define method
  const method = req.method;
  switch (url) {
    case "/":
      //write client response
      res.write(`
    &lt;h1&gt;Welcome to our nodeJS Server&lt;/h1&gt; 
    `);
      //send client response
      res.end();
      break;
    case "/logger":
      if (method === "GET") {
        res.write(`
        &lt;h1  
        &gt;Welcome to our Logger Application&lt;/h1&gt; 
        `);
        logger.renderLoggerForm(res);
      } else if (method === "POST") {
        res.write("POST HERE FOR LOGGER! ^__X");
      }

      res.end();
      break;
    default:
      res.write(`
      &lt;h1&gt;404 page not found X_x&lt;/h1&gt;  
      `);
      res.end();
      break;
  }
});

//log some output to see everything's ok
console.log(`Server is running on port: 
            ${PORT} so our API is alive =)
            `);

//start the server
server.listen(PORT);

    </pre>
    <p class="text">
      Now, if we hit the <span class="snippet">/logger</span> endpoint with a
      <span class="snippet">GET</span> request, we get the form displayed, but
      if we submit the form, we get the "POST.." print. Let's just replace that
      with the form processing logic. Replace the
      <span class="snippet">res.write("POST HERE FOR LOGGER! ^__X");</span>
      with: <span class="snippet"> logger.processForm(req, res);</span>
    </p>
    <p class="text">
      Next, add the <span class="snippet">processForm()</span> method inside the
      <span class="snippet">logger.js</span>:
    </p>
    <pre class="code">
      const logger = {
        renderLoggerForm: (res) => {
          res.write(`
                  &lt;form
                      style="${logger.formStyles}"
                      action="/logger"
                      method="POST"
                  &gt;
                      &lt;input 
                        name="logText"
                        style="${logger.formField}"
                        type="text"&gt;
                      &lt;button 
                        style="${logger.formBtn}"
                        type="submit"&gt;
                        Log something
                      &lt;/button&gt;
                  &lt;/form>
              `);
        },
      
        formStyles: `
              display:block; 
              margin:auto; 
              margin-top:1rem;
              padding:2rem; 
              font-size:1rem; 
              background: #ddd; 
              border: 2px solid #000; 
              border-radius:5px;
              max-width:600px;
          `,
      
        formBtn: `
          display:block;
          margin:auto;
          width:60%;
          padding:0.5rem;
          font-size:2rem;
          margin-top:3rem;
        `,
      
        formField: `
          display:block;
          margin:auto;
          margin-top:1rem;
          text-align:center;
          font-size:2rem;
        `,

        processForm: (req, res) => {
          const body = [];
          //on data to start reading data
          req.on("data", (chunk) => { 
            body.push(chunk);
          });

          //on end to finish reading stream
          req.on("end", () => {
            const parsedBody = Buffer.concat(body).toString(); 
            res.write("POST HERE");
            res.end();
          });
        },
      };
            
      module.exports = logger;   
    </pre>
    <p class="text">
      Note how we are using 2 events inside the
      <span class="snippet">processForm()</span> method. The submit data comes
      actually as a stream that we are reading inside of our application. We are
      reading it in 'chunks'. The event for that is the
      <span class="snippet">on("data", ()=> {})</span> event which takes in a
      callback function as you can see. Inside of that callback we push the
      chunks onto the 'body' array. Finally after all the data has been sent and
      all the chunks 'pushed' onto the array, we use the
      <span class="snippet">on("end", ()=> {})</span> event with another
      callback. Inside of it we use the built-in Buffer object to concatenate
      the chunks and parse them as string. The result of that we are logging it.
      Try submitting the form and you will see logged the value of your submit.
      So our data has now hit the server. Let's make the
      <span class="snippet">processForm()</span> call another method (we'll call
      it <span class="snippet">logToFile()</span> ) this time. Add the below
      line at the end of the <span class="snippet">processForm()</span> method
      and delete the <span class="snippet">res.write("POST HERE")</span> and the
      <span class="snippet">res.end()</span> calls:
    </p>
    <pre class="code">
      logger.logToFile(res, parsedBody);
    </pre>
    <p class="text">
      Let's now complete the <span class="snippet">logger.js</span> file with
      our last method. We will use the <span class="snippet">fs</span> module
      for that. <span class="snippet">fs</span> stands for file system and it is
      a module that allows us to read from and write to files. Replace the code
      in <span class="snippet">logger.js</span> as per below:
    </p>
    <pre class="code">
      const fs = require("fs");
// const path = require("path");
const logger = {
  renderLoggerForm: (res) => {
    res.write(`
            &lt;form
                style="${logger.formStyles}"
                action="/logger"
                method="POST"
            &gt;
                &lt;input 
                  name="logText"
                  style="${logger.formField}"
                  type="text"&gt;
                &lt;button 
                  style="${logger.formBtn}"
                  type="submit"&gt;
                  Log something
                &lt;/button&gt;
            &lt;/form&gt;
        `);
  },

  formStyles: `
        display:block; 
        margin:auto; 
        margin-top:1rem;
        padding:2rem; 
        font-size:1rem; 
        background: #ddd; 
        border: 2px solid #000; 
        border-radius:5px;
        max-width:600px;
    `,

  formBtn: `
    display:block;
    margin:auto;
    width:60%;
    padding:0.5rem;
    font-size:2rem;
    margin-top:3rem;
  `,

  formField: `
    display:block;
    margin:auto;
    margin-top:1rem;
    text-align:center;
    font-size:2rem;
  `,

  processForm: (req, res) => {
    const body = [];
    //on data to start reading data
    req.on("data", (chunk) => {
      body.push(chunk);
    });

    //on end to finish reading stream
    req.on("end", () => {
      const parsedBody = Buffer.concat(body).toString(); 
      logger.logToFile(res, parsedBody);
    });
  },

  logToFile: (res, parsedBody) => {
    //define logs dir
    const logDirectory = "./logs";
    //process data to log
    const dataToLog = parsedBody
    .split("=")[1].split("+").join(" ");

    const date = new Date()
      .toString()
      .replace(/\S+\s(\S+)\s(\d+)\s(\d+)\s.*/, "$2-$1-$3");

    //create dir if it does not exist
    if (!fs.existsSync(logDirectory)) {
      fs.mkdirSync(logDirectory);
    }
    fs.appendFile(
      "./logs/logs.txt",
      `Logged at: ${date}, textLogged: ${dataToLog} \n`,
      function (err) {
        if (err) throw err;
      }
    );
    //redirect back to homepage
    res.statusCode = 302; //redirect
    res.setHeader("Location", "/");

    return res.end();
  },
};

module.exports = logger;
    </pre>
    <p class="text">
      Now our logger logs to a file called
      <span class="snippet">logs.txt</span> which is created in the
      <span class="snippet">/logs</span> directory on our server. If the 'logs'
      directory does not exist, it creates it.
    </p>
    <p class="text center bold">CRUD - contacts list- mini project</p>
    <p class="text">
      We are now going to create a contact manager application in which we can
      register contacts, look them up, edit and delete them. We are going to
      reach it by hitting the
      <span class="snippet"
        ><a href="http://localhost:5000/contact-manager"
          >http://localhost:5000/contact-manager</a
        ></span
      >
      endpoint. All contacts will be displayed on the same page and the CRUD
      operations will be perform there.For now that page just returns a 404
      error, so let's add a route for it in the
      <span class="snippet">server.js</span>. Add the case for it just above the
      default one:
    </p>
    <pre class="code">
      case "/contact-manager":
      res.write("Contact Manager Here..");
      res.end();
      break;
    </pre>
    <p class="text">
      Create a <span class="snippet">contactManager.js</span> and add the below
      to it:
    </p>
    <pre class="code">
      const contactManager = {
        displayWelcomeScreen: (res) => {
          res.write(`
              &lt;div style="${contactManager.card}"&gt;
                  &lt;h1&gt;Welcome to contact manager&lt;/h1&gt;
                  &lt;p style="${contactManager.text}"&gt;
                  An app to manage all your contacts&lt;/p&gt;
              &lt;/div&gt;
              `);
        },
      
        card: `
          text-align:center;
          padding: 1rem;
          display:block;
          margin:auto; 
          margin-top:2rem;
          background: blue;
          color: #fff;
          width:60%;
          max-width:600px;
          border: 15px solid #bbb;
          border-radius: 5px;
        `,
      
        text: `
        font-weight: 900;
        `,
      };
      
      module.exports = contactManager;
      
    </pre>
    <p class="text">
      Next import the module up top in
      <span class="snippet">server.js</span> and replace the
      <span class="snippet">res.write("Contact Manager Here..");</span> call in
      the <span class="snippet">/contact-manager</span> route with a call to our
      native module's <span class="snippet">displayWelcomeScreen(res)</span>:
    </p>
    <pre class="code">
//put this up top in server.js
const contactManager = 
require("./custom_modules/contactManager");

//call the displayWelcomeScreen in the /contact-manager route
displayWelcomeScreen(res);
    </pre>
    <p class="text">
      Next if you go to
      <span class="snippet"
        ><a href="http://localhost:5000/contact-manager"
          >http://localhost:5000/contact-manager</a
        ></span
      >
      you will see the welcoming screen.
    </p>
    <p class="text">
      Let's now create a submit form which will be used to add our contacts. Add
      the below method to <span class="snippet">contactManager.js</span>:
    </p>
    <pre class="code">
      displayAddContact: (res) => {
        res.write(`4
        &lt;form
        style="${logger.formStyles}"
        action="/contact-manager/add"
        method="POST"
    &gt;
        &lt;input 
          name="name"
          style="${logger.formField}"
          type="text"
          placeholder="name"&gt;
          &lt;input 
          name="email"
          style="${logger.formField}"
          type="email"
          placeholder="e-mail"&gt;
          &lt;input 
          name="phone"
          style="${logger.formField}"
          type="phone"
          placeholder="phone"&gt;
        &lt;button 
          style="${logger.formBtn}"
          type="submit"&gt;
          Add contact
        &lt;/button&gt;
    </form>
        `);
      },
    </pre>
    <p class="text">
      As you can see, the add form uses some of the logger styles so just import it up top in the 
      <span class="snippet">contactManager.js</span> module. Now on the contact manager page you also see the form for adding a
      new contact.  Let's add quickly a case for adding the contact in the <span class="snippet">server.js</span>. Add it right 
      above the default case:
    </p>
    <pre class="code">
      if (method === "POST") {
        contactManager.addContact(req, res);
      }
      break;
    </pre>
    <p class="text">
      Next, add the <span class="snippet">addContact()</span> method inside the <span class="snippet">contactManager.js</span>
      file right under displayAddContact():
    </p>
    <pre class="code">
      addContact: (req, res) => {
        res.write("ADDING CONTACT HERE");
      }
    </pre>
    <p class="text">
      Now if you submit the form as it is, you get the response from the method. Let's modify it so that it does what it's supposed 
      to namely adding a contact to a JSON file. That's where we'll read from and display all the contacts. First remove the <span class="snippet">res.end()</span>
      call from after calling <span class="snippet">addContact()</span> and import up top in the <span class="snippet">contactManager.js</span> module the filesystem module. Next
      create a <span class="snippet">contacts.json</span> file inside the <span class="snippet">custom_modules</span> directory and replace the <span class="snippet">addContact()</span> method in the contact manager module as
      per below:
    </p>
    <pre class="code">
addContact: (req, res) => {
  const body = [];
  //on data to start reading data
  req.on("data", (chunk) => {
    body.push(chunk);
  });

  //on end to finish reading stream
  req.on("end", () => {
    //parse data
    const parsedBody = Buffer.concat(body).toString();
    const name = parsedBody
    .split("&")[0]
    .split("=")[1]
    .split("+")
    .join(" ")
    .trim();
  const email = parsedBody
    .split("&")[1]
    .split("=")[1]
    .split("%")
    .join("@")
    .trim();
    const phone = parsedBody.split("&")[2].split("=")[1].trim();
    const added = new Date()
      .toString()
      .replace(/\S+\s(\S+)\s(\d+)\s(\d+)\s.*/, "$2-$1-$3");
    const contact = {
      name,
      email,
      phone,
      added,
    }; 

    fs.readFile(
        "./custom_modules/contacts.json", 
        "utf8", (err, data) => {
      if (err) {
        throw err;
      }
      let resources;
      let objToWrite = {};
      let contacts;
      if (data !== "") {
        //some contacts already
        contacts = JSON.parse(data).contacts;
        contacts.unshift(contact);
        objToWrite.contacts = contacts; 
      } else {
        //no contacts
        contacts = [];
        contacts.unshift(contact);
        objToWrite.contacts = contacts;
      }
      fs.writeFile(
        "./custom_modules/contacts.json",
        JSON.stringify(objToWrite),
        (err) => {}
      );
      //redirect back to contact-manager page
      res.statusCode = 302; //redirect
      res.setHeader("Location", "/contact-manager");
      res.end();
    });
  });
}
    </pre>
    <p class="text">
      Now our contact manager application stores the contacts in a <span class="snippet">contacts.json</span> file stored in the <span class="snippet">/custom_modules</span>
      directory. Test it out and see how it works. Try deleting all the data inside the contacts file and then add more contacts.
    </p>
    <p class="text">
      Let's now work quickly onto the display contacts method. We need one to see the contacts we currently have. Call it right under the <span class="snippet">/contact-manager</span> route
      right after <span class="snippet">displayAddContact()</span>:
    </p>
    <pre class="code">
      case "/contact-manager":
      contactManager.displayWelcomeScreen(res);
      contactManager.displayAddContact(res);
      contactManager.displayContacts(res);
      res.end();
      break;
    </pre>
    <p class="text">
      Next, add the code for it inside <span class="snippet">contactManager.js</span> right after <span class="snippet">addContact()</span>:
    </p>
    <pre class="code">
      displayContacts: (res) => {
        fs.readFile("./custom_modules/contacts.json", 
        "utf8", (err, data) => {
          if (err) {
            throw err;
          } 
          let contacts;
          if (data !== "") {
            contacts = JSON.parse(data).contacts;
          } else {
            contacts = null;
          }
          if (contacts === null) {
            res.write(`
       &lt;div style="${contactManager.card}"&gt;
               &lt;h1&gt;No Contacts Here&lt;/h1&gt; 
          &lt;/div&gt;
          `);
          } else {
            res.write(`
            &lt;div style="${contactManager.card}"&gt;
              &lt;h1&gt;Current Contacts&lt;/h1&gt; 
            &lt;/div&gt;`);
            contacts.map((c) =&gt; {
              res.write(` 
             &lt;div style=${contactManager.card};&gt;
               &lt;p&gt;Name: ${c.name}&lt;/p&gt;
               &lt;p&gt;E-mail: ${c.email}&lt;/p&gt;
               &lt;p&gt;Phone: ${c.phone}&lt;/p&gt;
               &lt;p&gt;Date added: ${c.added}&lt;/p&gt;
               &lt;p&gt;&lt;a href="#"&gt;Delete Contact&lt;/a&gt;&lt;/p&gt;
               &lt;p&gt;&lt;a href="#"&gt;Edit Contact&lt;/a&gt;&lt;/p&gt;
             &lt;hr style="max-width:15rem;"&gt;
           &lt;/div&gt;
          `);
            });
          }
          res.end();
        });
      }
    </pre>
    <p class="text">
      Next, we need to set up the way methods are called in the <span class="snippet">/contact-manager</span> route. Modify it as per below:
    </p>
     <pre class="code">
      case "/contact-manager":
      contactManager.displayWelcomeScreen(res);
      contactManager.displayAddContact(res);
      contactManager.displayContacts(res);
      break;
     </pre>
     <p class="text">
       As you can see, we have called the <span class="snippet">displayContacts()</span> method last and we have removed the call to <span class="snippet">res.end()</span>.
       The reason we did that, is because we are sending the client  response in the <span class="snippet">displayContacts()</span> method which takes the longest to execute because it
       reads through the JSON file. Now we can add and see contacts. Let's do next the edit contact.
     </p>
     <p class="text">
       !!!!!!!!!!!!!!!!!//You added content type in server.js + made edit form point to route + created 2 methods to render the form and process the request for the route
     </p>
    <p class="text center bold">
      Image uploader & gallery project (to define scope and all)
    </p>
    <p class="text center bold">
      Quick Login system (could be a plugin which we can add to any basic
      application- to define scope and all)
    </p>
    <p class="text center bold">Email sender (to define scope and all)</p>
  </body>
</html>
